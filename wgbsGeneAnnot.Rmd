---
title: "wgbsGeneAnnot"
author: "Maya Arvanitis"
date: "10/28/2024"
output: html_document
---

---
title: "wgbsGeneAnnot"
author: "Maya Arvanitis"
date: "10/28/2024"
output: html_document
---

## Introduction

Whole genome bisulfite sequencing (WGBS) is a powerful technique used to assess DNA methylation across the entire genome at single-base resolution. 

Unlike array-based methods, which focus on a limited set of CpG sites, WGBS provides a comprehensive view of methylation patterns, offering the potential to uncover novel regulatory elements and regions associated with gene expression.

However, a challenge with WGBS data is the lack of direct mapping between CpG sites and gene annotations, making it necessary to perform additional gene annotation steps to link methylation changes to specific genes and biological functions.

## Purpose of Gene Annotation in WGBS Analysis

The goal of gene annotation in WGBS analysis is to map CpG sites to their corresponding genes or regulatory regions, enabling functional interpretation of the observed methylation patterns. 

Without this mapping, it would be difficult to understand the biological significance of differentially methylated regions (DMRs) or sites, limiting the ability to link epigenetic changes to gene expression and cellular functions. 

Gene annotation allows researchers to perform downstream analyses such as gene set enrichment analysis, pathway analysis, and integration with other genomic data.

## Methodology

Gene annotation for WGBS involves linking CpG sites with nearby genes based on their genomic coordinates. This process can be challenging because WGBS data provides information on methylation at individual CpG sites scattered throughout the genome, rather than pre-defined CpG regions associated with genes. 

The following steps will be used to perform gene annotation:

1. **Mapping Genomic Coordinates to Genes:** 

   The first step is to map the coordinates of the CpG sites (chromosome, start, and end positions) to nearby genes. This can be done using external gene annotation databases such as Ensembl or UCSC, which provide the genomic locations of genes and other functional elements. Tools like `biomaRt` or `annotatr` can facilitate this process by querying these databases for gene information based on the provided coordinates.

2. **Annotating with Genomic Ranges:** 

   In cases where CpG sites do not fall directly within gene bodies, it may be necessary to extend the search to include nearby regulatory regions (e.g., promoters or enhancers) by using a genomic range overlap approach. This involves defining a window around each CpG site and checking for overlaps with annotated gene regions using packages like `GenomicRanges`.

3. **Validation and Cross-Referencing:** 

   To ensure the accuracy of the annotation, multiple sources of gene annotations can be used to cross-reference the mapped genes. For instance, gene assignments from both `biomaRt` and `annotatr` can be compared, and only consistent annotations may be retained.

4. **Handling Ambiguities:** 

   In some cases, a CpG site may overlap with more than one gene or may be located in intergenic regions. In such cases, appropriate rules will be defined to assign the CpG site to the most relevant gene, or to mark it as intergenic if no clear assignment can be made.

This gene annotation process is a crucial step in linking WGBS methylation data to biological functions, enabling a more meaningful interpretation of the epigenetic changes observed in the data.

Note: In this file I will be working with a sample of the differential methylation data (N = 10 000) simply for running time / debugging purposes.

```{r, results="hide", error = FALSE, message=FALSE, warning=FALSE}
# Load necessary libraries
library(biomaRt)
library(annotatr)
library(GenomicRanges)
library(dplyr)
library(readr)
library(ggplot2)
```

```{r}
# Read the data
diff_data <- readr::read_tsv("data_maya/WTvsG34R_CRX_10W.diff_meth.tsv.gz", col_names = TRUE)

# Inspect the data
print(head(diff_data))
```

We will filter the data to select for significant p-values first.
```{r}
significant_cpgs <- diff_data %>% filter(pvalue < 0.05)
```

Now, we can separate this data into 2 groups: 
1. p-values with positive changes (hypermethylation)
2. p-values with negative changes (hypomethylation)

```{r}
hyper_cpgs <- significant_cpgs %>% filter(meth.diff > 0)
hypo_cpgs <- significant_cpgs %>% filter(meth.diff < 0)

head(hyper_cpgs)
head(hypo_cpgs)
dim(hyper_cpgs)
dim(hypo_cpgs)
```

Now we have two groups we are working with:
1. `hyper_cpgs` : 629752
2. `hypo_cpgs` : 755228

We will now perform gene annotation using biomaRt.

```{r}
# Step 1: Mapping Genomic Coordinates to Genes using biomaRt
# Connect to the Ensembl database for mouse genome annotation
ensembl <- useMart("ensembl", dataset = "mmusculus_gene_ensembl", host = "https://asia.ensembl.org")
```

```{r}
#Taking a sample set of the cpgs for debugging / running time purposes
# Step 2: Take a subset of each for testing
set.seed(123)  # For reproducibility
hyper_cpgs_subset <- hyper_cpgs %>% sample_n(1000)
hypo_cpgs_subset <- hypo_cpgs %>% sample_n(1000)

hyper_cpgs_subset <- hyper_cpgs_subset %>%
  mutate(chr = as.numeric(chr)) %>%  # Converts chromosome values to numeric, leaves NA for non-numeric
  arrange(chr, start)  

# Step 3: Check the subset data
head(hyper_cpgs_subset)
head(hypo_cpgs_subset)
dim(hyper_cpgs_subset)
dim(hypo_cpgs_subset)
```
```{r}
# Load required libraries
library(GenomicRanges)
library(GenomicFeatures)
library(AnnotationDbi)
```

```{r}
# Remove columns we don't need
hyper_cpgs_subset <- hyper_cpgs_subset[, c("chr", "start", "end", "pvalue")]
hyper_cpgs_subset <- hyper_cpgs_subset %>%
  mutate(cpg_id = paste0(chr, "_", start, "_", end))


# Display the result
print(hyper_cpgs_subset)
```

```{r}

# Construct chromosomal_region in the query dataset
hyper_cpgs_subset <- hyper_cpgs_subset %>%
  mutate(query_id = paste0(chr, "_", start, "_", end),
         chromosomal_region = paste0(chr, ":", start, "-", end))

# Retrieve gene annotations for hypermethylated CpGs
hyper_annotations <- getBM(
  attributes = c("chromosome_name", "start_position", "end_position", "ensembl_gene_id"),
  filters = "chromosomal_region",
  values = hyper_cpgs_subset$chromosomal_region,
  mart = ensembl
)
# Add chromosomal_region column to the result
hyper_annotations <- hyper_annotations %>%
  mutate(chromosomal_region = paste0(chromosome_name, "_", start_position, "_", end_position))

# Display the first few rows
head(hyper_annotations)
```
```{r}
library(dplyr)
# Assume hyper_cpgs_subset has a 'cpg_id' column with the format "chr_start_end"

hyper_cpgs_subset <- as.data.frame(hyper_cpgs_subset)
# Extract chr, start, and end from cpg_id
hyper_cpgs_subset <- hyper_cpgs_subset %>%
  mutate(
    chr = sub("^(.*)_.*_.*$", "\\1", cpg_id),
    start = as.numeric(sub("^.*_(.*)_.*$", "\\1", cpg_id)),
    end = as.numeric(sub("^.*_.*_(.*)$", "\\1", cpg_id))
  )

# Parse 'chromosomal_region' in hyper_annotations to chr, start, and end
hyper_annotations <- hyper_annotations %>%
  mutate(
    chr = sub("^(.*)_.*_.*$", "\\1", chromosomal_region),
    start = as.numeric(sub("^.*_(.*)_.*$", "\\1", chromosomal_region)),
    end = as.numeric(sub("^.*_.*_(.*)$", "\\1", chromosomal_region))
  )

# Convert CpG data to GRanges object
cpg_gr <- GRanges(
  seqnames = hyper_cpgs_subset$chr,
  ranges = IRanges(start = hyper_cpgs_subset$start, end = hyper_cpgs_subset$end),
  cpg_id = hyper_cpgs_subset$cpg_id
)

# Convert gene annotation data to GRanges object
gene_gr <- GRanges(
  seqnames = hyper_annotations$chr,
  ranges = IRanges(start = hyper_annotations$start, end = hyper_annotations$end),
  ensembl_gene_id = hyper_annotations$ensembl_gene_id
)

# Find overlaps between CpG ranges and gene ranges
overlaps <- findOverlaps(cpg_gr, gene_gr)

# Map each CpG to all overlapping genes
mapped_genes <- data.frame(
  cpg_id = mcols(cpg_gr)$cpg_id[queryHits(overlaps)],
  ensembl_gene_id = mcols(gene_gr)$ensembl_gene_id[subjectHits(overlaps)]
)

hyper_cpgs_subset <- as_tibble(hyper_cpgs_subset)

# Now, retry the join operation with dplyr::select
mapped_genes <- mapped_genes %>%
  left_join(hyper_cpgs_subset %>% dplyr::select(cpg_id, pvalue), by = "cpg_id")

# Check the result
print(head(mapped_genes))
```

```{r}
library(methylGSA)
```

```{r}
cpg_pval <- setNames(mapped_genes$pvalue, mapped_genes$cpg_id)
head(cpg_pval)
```



```{r}
# Check the column names in mapped_genes
colnames(mapped_genes)

# Ensure that `mapped_genes` has only the CpG and Ensembl gene ID columns
mapped_genes_prepared <- mapped_genes[, c("cpg_id", "ensembl_gene_id")]

# Rename columns to match the expected format for `prepareAnnot`
colnames(mapped_genes_prepared) <- c("CpG", "Gene")

# Verify that there are no duplicates
any(duplicated(mapped_genes_prepared$CpG))  # Should return FALSE

# Use the Ensembl IDs directly in FullAnnot
FullAnnot2 <- mapped_genes_prepared[, c("CpG", "Gene")]
colnames(FullAnnot2) <- c("cpg", "gene")  # Rename to expected format

# Display a sample of FullAnnot to verify
head(FullAnnot2)

```
```{r}
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("msigdb")
```

```{r}
library(msigdb)
library(ExperimentHub)
library(GSEABase)
```

```{r}
#retrieve hallmark mouse 
# Retrieve hallmark gene sets for mouse
msigdb.mm <- getMsigdb(org = 'mm', id = 'ENSEMBL', version = '7.4')

hallmarks = subsetCollection(msigdb.mm, 'h')
```

```{r}
# Convert hallmarks to a list of gene symbols by hallmark name
hallmarks_list <- lapply(hallmarks, function(gs) {
  # Extract gene symbols and set name for each GeneSet object
  setNames(list(gs@geneIds), gs@setName)
})

# Flatten the list structure to obtain a single list with hallmark names as keys
hallmarks_list <- unlist(hallmarks_list, recursive = FALSE)

```

```{r}
print(class(cpg_pval))      # Should output "numeric"
print(is.numeric(cpg_pval)) # Should return TRUE
```

```{r}
if (any(is.na(cpg_pval))) {
    cpg_pval <- cpg_pval[!is.na(cpg_pval)] 
}
```

```{r}
if (length(cpg_pval) == 0) {
    stop("cpg.pval is empty. Please ensure it contains valid p-values.")
}
```

```{r}
cpg_pval = na.omit(cpg_pval)
FullAnnot <- na.omit(FullAnnot)

```

```{r}
# Filter cpg_pval to keep only CpGs that are in FullAnnot
valid_cpg_ids <- FullAnnot$cpg_id
cpg_pval <- cpg_pval[names(cpg_pval) %in% valid_cpg_ids]

# Ensure there are still CpGs left in cpg_pval after filtering
if (length(cpg_pval) == 0) {
    stop("cpg_pval is empty after filtering. Ensure there are matching CpGs between cpg_pval and FullAnnot.")
}
```


```{r}
# Run the methylglm function
methylglm_results_pos <- methylglm(
    cpg.pval = cpg_pval,
    array.type = "custom",
    FullAnnot = FullAnnot2,
    GS.list = hallmarks_list,          
    minsize = 10,
    maxsize = 700
)

head(methylglm_results_pos)
```

```{r}
# methylglm call for hypomethylated cpgs 
methylglm_results_neg <- methylglm(
    cpg.pval = setNames(hypo_cpgs$pvalue, hypo_cpgs$cpg_id),
    array.type = "custom",
    FullAnnot = hypo_genes,
    GS.type = "GO",
    minsize = 200,
    maxsize = 500
)
```


