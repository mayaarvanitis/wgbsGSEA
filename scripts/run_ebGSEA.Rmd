---
title: "run_ebGSEA"
author: "Maya Arvanitis"
date: "11/18/2024"
output: html_document
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
# Install remotes if not already installed
if (!requireNamespace("remotes", quietly = TRUE)) {=
    install.packages("remotes")
}

# Install ebGSEA from GitHub
remotes::install_github("aet21/ebGSEA")
```

```{r}
# Load required packages
library(ebGSEA)
library(dplyr)
library(GenomicRanges)
library(biomaRt)
library(readr)
library(ggplot2)
library(dplyr)
```

```{r}
# Connect to Ensembl for mouse genome annotation
ensembl <- useMart("ensembl", dataset = "mmusculus_gene_ensembl")
```

We need to prepare two things: 
1. the phenotype vector 
2. the beta value matrix 

```{r}
library(msigdb)
```

```{r}
# Retrieve hallmark gene sets for mouse with Ensembl IDs
msigdb.mm <- getMsigdb(org = 'mm', id = 'SYM', version = '7.4')
hallmarks = subsetCollection(msigdb.mm, 'h')

# Convert hallmarks to a list of gene symbols by hallmark name
hallmarks_list <- lapply(hallmarks, function(gs) {
  # Extract gene symbols and set name for each GeneSet object
  setNames(list(gs@geneIds), gs@setName)
})

# Flatten the list structure to obtain a single list with hallmark names as keys
ptw.ls <- unlist(hallmarks_list, recursive = FALSE)
```

```{r}
# Load the percentage methylation data
percentage_meth <- read_tsv("data_maya/WTvsG34R_CRX_10W.percentage_meth.tsv.gz")

# Display the first few rows to confirm the structure
head(percentage_meth)
```

```{r}
set.seed(123)

# Number of rows to subset (adjust as needed)
num_rows <- 1000

# Ensure the subset size does not exceed the number of rows in the original data
num_rows <- min(num_rows, nrow(percentage_meth))

# Randomly sample rows from the data
percentage_meth_subset <- percentage_meth[sample(1:nrow(percentage_meth), num_rows), ]

percentage_meth_subset <- percentage_meth_subset %>%
  mutate(cpg_id = paste0(chr, "_", start, "_", end))

# Display the dimensions and the first few rows of the subset
cat("Dimensions of the subset:", dim(percentage_meth_subset), "\n")
print(head(percentage_meth_subset))
```

```{r}
# Construct chromosomal_region in the query dataset
percentage_meth_subset <- percentage_meth_subset %>%
  mutate(query_id = paste0(chr, "_", start, "_", end),
         chromosomal_region = paste0(chr, ":", start, "-", end))

# Retrieve gene annotations for hypermethylated CpGs
annotations <- getBM(
  attributes = c("chromosome_name", "start_position", "end_position", "external_gene_name"),
  filters = "chromosomal_region",
  values = percentage_meth_subset$chromosomal_region,
  mart = ensembl
)

# Add chromosomal_region column to the result
annotations <- annotations %>%
  mutate(chromosomal_region = paste0(chromosome_name, "_", start_position, "_", end_position))

# Filter out rows with NA in the external_gene_name column
annotations <- annotations %>%
  filter(!is.na(external_gene_name) & external_gene_name != "" & !grepl("^\\s*$", external_gene_name))

# Display the first few rows to confirm
head(annotations)
```

```{r}
# Assume hyper_cpgs_subset has a 'cpg_id' column with the format "chr_start_end"
percentage_meth_subset <- as.data.frame(percentage_meth_subset)

# Extract chr, start, and end from cpg_id
percentage_meth_subset <- percentage_meth_subset %>%
  mutate(
    chr = sub("^(.*)_.*_.*$", "\\1", cpg_id),
    start = as.numeric(sub("^.*_(.*)_.*$", "\\1", cpg_id)),
    end = as.numeric(sub("^.*_.*_(.*)$", "\\1", cpg_id))
  )

# Parse 'chromosomal_region' in hyper_annotations to chr, start, and end
annotations <- annotations %>%
  mutate(
    chr = sub("^(.*)_.*_.*$", "\\1", chromosomal_region),
    start = as.numeric(sub("^.*_(.*)_.*$", "\\1", chromosomal_region)),
    end = as.numeric(sub("^.*_.*_(.*)$", "\\1", chromosomal_region))
  )

# Convert CpG data to GRanges object
cpg_gr <- GRanges(
  seqnames = percentage_meth_subset$chr,
  ranges = IRanges(start = percentage_meth_subset$start, end = percentage_meth_subset$end),
  cpg_id = percentage_meth_subset$cpg_id
)

# Convert gene annotation data to GRanges object
gene_gr <- GRanges(
  seqnames = annotations$chr,
  ranges = IRanges(start = annotations$start, end = annotations$end),
  external_gene_name = annotations$external_gene_name
)

# Find overlaps between CpG ranges and gene ranges
overlaps <- findOverlaps(cpg_gr, gene_gr)

# Map each CpG to all overlapping genes
mapped_genes <- data.frame(
  cpg_id = mcols(cpg_gr)$cpg_id[queryHits(overlaps)],
  external_gene_name = mcols(gene_gr)$external_gene_name[subjectHits(overlaps)]
)

percentage_meth_subset <- as_tibble(percentage_meth_subset)

mapped_genes <- mapped_genes %>%
  left_join(percentage_meth_subset %>% dplyr::select(cpg_id), by = "cpg_id")

# Check the result
print(head(mapped_genes))
```

```{r}
library(dplyr)
library(tibble)

# Convert `mapped_genes` into a list where each CpG ID is associated with one or more gene names
custom_mapping <- mapped_genes %>%
  group_by(cpg_id) %>%
  summarise(genes = list(unique(external_gene_name))) %>%
  deframe()

# Display a preview of the custom mapping
head(custom_mapping, 15)

invalid_mappings <- which(sapply(custom_mapping, length) == 0)
if (length(invalid_mappings) > 0) {
  cat("Found empty mappings for CpGs:\n")
  print(names(custom_mapping)[invalid_mappings])
  custom_mapping <- custom_mapping[-invalid_mappings]
  cat("Updated custom_mapping size:", length(custom_mapping), "\n")
}

genes_in_mapping <- unique(unlist(custom_mapping))
genes_in_ptw <- unique(unlist(ptw.ls))

common_genes <- intersect(genes_in_mapping, genes_in_ptw)
cat("Number of common genes between custom_mapping and ptw.ls:", length(common_genes), "\n")

if (length(common_genes) == 0) {
  stop("Error: No overlap between custom_mapping and ptw.ls genes.")
}
```

```{r}
# Ensure the data is a regular data frame
percentage_meth_df <- as.data.frame(percentage_meth_subset)

percentage_meth_df <- percentage_meth_df[, !colnames(percentage_meth_df) %in% c("start", "end")]

# Identify the columns with numeric data (assuming they contain methylation percentages)
numeric_columns <- sapply(percentage_meth_df, is.numeric)

# Extract only the numeric columns (methylation percentages)
beta_values <- percentage_meth_df[, numeric_columns] / 100  # Convert percentages to beta values

# Convert the extracted values to a matrix
beta_matrix <- as.matrix(beta_values)

# Set row names as CpG site identifiers in the "chr_start_end" format
rownames(beta_matrix) <- percentage_meth_df$cpg_id

# Display the dimensions and a preview of the matrix
cat("Dimensions of the beta matrix:", dim(beta_matrix), "\n")
head(beta_matrix)
```

```{r}
# Create a phenotype vector
pheno.v <- c("SK059_2427_WT_CRX", "SK060_2616_WT_CRX", "SK061_2617_G34R_CRX", "SK062_2428_G34R_CRX")

pheno.v_binary <- ifelse(grepl("WT", pheno.v), 0, 1)

# Display the phenotype vector
print(pheno.v_binary)
```

```{r}
source("doGT_custom.R")
```

```{r}
# Install the globaltest package if not already installed
if (!requireNamespace("globaltest", quietly = TRUE)) {
  install.packages("BiocManager")
  BiocManager::install("globaltest")
}

# Load the globaltest package
library(globaltest)
```

```{r}
# Double-check formatting of CpG IDs in custom_mapping
names(custom_mapping) <- gsub(":", "_", names(custom_mapping))
names(custom_mapping) <- gsub("-", "_", names(custom_mapping))

# Ensure that the format matches with rownames of beta_matrix
common_cpgs <- intersect(rownames(beta_matrix), names(custom_mapping))
cat("Number of common CpGs:", length(common_cpgs), "\n")

common_cpgs <- intersect(rownames(beta_matrix), names(custom_mapping))
cat("Number of common CpGs:", length(common_cpgs), "\n")

# If overlap is zero, display a sample of CpG IDs
if (length(common_cpgs) == 0) {
  cat("Sample CpG IDs from beta_matrix:\n")
  print(head(rownames(beta_matrix)))
  
  cat("Sample CpG IDs from custom_mapping:\n")
  print(head(names(custom_mapping)))
}

# Check for missing values in beta_matrix
if (any(is.na(beta_matrix)) || any(is.nan(beta_matrix)) || any(is.infinite(beta_matrix))) {
  stop("Error: Beta matrix contains missing, NaN, or infinite values.")
}

# Check for empty gene lists in custom_mapping
empty_genes <- which(sapply(custom_mapping, length) == 0)
if (length(empty_genes) > 0) {
  cat("Found empty mappings for CpGs:\n")
  print(names(custom_mapping)[empty_genes])
  
  # Remove empty mappings
  custom_mapping <- custom_mapping[-empty_genes]
  cat("Updated custom_mapping size:", length(custom_mapping), "\n")
}

```

```{r}
common_cpgs <- intersect(rownames(beta_matrix), names(custom_mapping))
cat("Number of common CpGs:", length(common_cpgs), "\n")
# Subset custom_mapping and beta_matrix to include only common CpGs
custom_mapping_valid <- custom_mapping[common_cpgs]
beta_matrix_valid <- beta_matrix[common_cpgs, , drop = FALSE]

# Check the dimensions and preview
cat("Dimensions of valid beta matrix:", dim(beta_matrix_valid), "\n")
print(head(beta_matrix_valid))

```
```{r}
rownames(beta_matrix_valid) <- trimws(rownames(beta_matrix_valid))
custom_mapping <- trimws(custom_mapping)

# Trim any leading/trailing whitespaces from both sets
rownames(beta_matrix_valid) <- trimws(rownames(beta_matrix_valid))
names(custom_mapping_valid) <- trimws(names(custom_mapping_valid))

# Recheck the intersection after trimming
cat("Number of common CpGs:", length(common_cpgs), "\n")

# Print the first few CpG IDs in both datasets for inspection
head(rownames(beta_matrix_valid))
head(names(custom_mapping_valid))

common_cpgs <- intersect(rownames(beta_matrix_valid), names(custom_mapping_valid))
length(common_cpgs)
```

```{r}
test_mclapply <- mclapply(1:5, function(i) i^2, mc.cores = 1)
print(test_mclapply)

```


```{r}
# Check for NA, NaN, or Inf in beta_matrix
if (any(is.na(beta_matrix_valid)) || any(is.nan(beta_matrix_valid)) || any(is.infinite(beta_matrix_valid))) {
  cat("Error: Beta matrix contains NA, NaN, or Inf values.\n")
} else {
  cat("No NA/NaN/Inf values in beta matrix.\n")
}

beta_matrix_valid <- beta_matrix_valid[complete.cases(beta_matrix_valid) & !apply(beta_matrix_valid, 1, function(row) any(is.nan(row) | is.infinite(row))), ]

```

```{r}
library(parallel)
library(ebGSEA)
library(globaltest)

tryCatch({
  sgt.m <- doGT_custom(
    pheno.v = pheno.v_binary,
    data.m = beta_matrix_valid,
    model = c("linear"),
    array = "custom",
    ncores = 1,
    custom_map = custom_mapping_valid
  )
  
  cat("Global Test completed successfully\n")
  print(head(sgt.m))
}, error = function(e) {
  cat("Error in doGT:", e$message, "\n")
})

```

```{r}
# Run pathway enrichment analysis
topGSEA.lm <- doGSEAwt(
  rankEID.m = sgt.m,
  ptw.ls = ptw.ls,
  ncores = 4,
  minN = 5,
  adjPVth = 0.05
)

# Display top results
head(topGSEA.lm[[1]])
```

```{r}
# Plot the AUC and adjusted p-values
ggplot(topGSEA.lm[[1]], aes(x = AUC, y = -log10(adjP))) +
  geom_point() +
  labs(x = "Area Under Curve", y = "-log10(Adjusted p-value)", title = "Pathway Enrichment Analysis") +
  theme_minimal()
```


