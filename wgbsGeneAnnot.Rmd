---
title: "wgbsGeneAnnot"
author: "Maya Arvanitis"
date: "10/28/2024"
output: html_document
---

---
title: "wgbsGeneAnnot"
author: "Maya Arvanitis"
date: "10/28/2024"
output: html_document
---

## Introduction

Whole genome bisulfite sequencing (WGBS) is a powerful technique used to assess DNA methylation across the entire genome at single-base resolution. 

Unlike array-based methods, which focus on a limited set of CpG sites, WGBS provides a comprehensive view of methylation patterns, offering the potential to uncover novel regulatory elements and regions associated with gene expression.

However, a challenge with WGBS data is the lack of direct mapping between CpG sites and gene annotations, making it necessary to perform additional gene annotation steps to link methylation changes to specific genes and biological functions.

## Purpose of Gene Annotation in WGBS Analysis

The goal of gene annotation in WGBS analysis is to map CpG sites to their corresponding genes or regulatory regions, enabling functional interpretation of the observed methylation patterns. 

Without this mapping, it would be difficult to understand the biological significance of differentially methylated regions (DMRs) or sites, limiting the ability to link epigenetic changes to gene expression and cellular functions. 

Gene annotation allows researchers to perform downstream analyses such as gene set enrichment analysis, pathway analysis, and integration with other genomic data.

## Methodology

Gene annotation for WGBS involves linking CpG sites with nearby genes based on their genomic coordinates. This process can be challenging because WGBS data provides information on methylation at individual CpG sites scattered throughout the genome, rather than pre-defined CpG regions associated with genes. 

The following steps will be used to perform gene annotation:

1. **Mapping Genomic Coordinates to Genes:** 

   The first step is to map the coordinates of the CpG sites (chromosome, start, and end positions) to nearby genes. This can be done using external gene annotation databases such as Ensembl or UCSC, which provide the genomic locations of genes and other functional elements. Tools like `biomaRt` or `annotatr` can facilitate this process by querying these databases for gene information based on the provided coordinates.

2. **Annotating with Genomic Ranges:** 

   In cases where CpG sites do not fall directly within gene bodies, it may be necessary to extend the search to include nearby regulatory regions (e.g., promoters or enhancers) by using a genomic range overlap approach. This involves defining a window around each CpG site and checking for overlaps with annotated gene regions using packages like `GenomicRanges`.

3. **Validation and Cross-Referencing:** 

   To ensure the accuracy of the annotation, multiple sources of gene annotations can be used to cross-reference the mapped genes. For instance, gene assignments from both `biomaRt` and `annotatr` can be compared, and only consistent annotations may be retained.

4. **Handling Ambiguities:** 

   In some cases, a CpG site may overlap with more than one gene or may be located in intergenic regions. In such cases, appropriate rules will be defined to assign the CpG site to the most relevant gene, or to mark it as intergenic if no clear assignment can be made.

This gene annotation process is a crucial step in linking WGBS methylation data to biological functions, enabling a more meaningful interpretation of the epigenetic changes observed in the data.

Note: In this file I will be working with a sample of the differential methylation data (N = 10 000) simply for running time / debugging purposes.

```{r, results="hide", error = FALSE, message=FALSE, warning=FALSE}
# Load necessary libraries
library(biomaRt)
library(annotatr)
library(GenomicRanges)
library(dplyr)
library(readr)
library(ggplot2)
```

```{r}
# Read the data
diff_data <- readr::read_tsv("data_maya/WTvsG34R_CRX_10W.diff_meth.tsv.gz", col_names = TRUE)

# Inspect the data
print(head(diff_data))
```

We will filter the data to select for significant p-values first.
```{r}
significant_cpgs <- diff_data %>% filter(pvalue < 0.05)
```

Now, we can separate this data into 2 groups: 
1. p-values with positive changes (hypermethylation)
2. p-values with negative changes (hypomethylation)

```{r}
hyper_cpgs <- significant_cpgs %>% filter(meth.diff > 0)
hypo_cpgs <- significant_cpgs %>% filter(meth.diff < 0)

head(hyper_cpgs)
head(hypo_cpgs)
dim(hyper_cpgs)
dim(hypo_cpgs)
```

Now we have two groups we are working with:
1. `hyper_cpgs` : 629752
2. `hypo_cpgs` : 755228

We will now perform gene annotation using biomaRt.

```{r}
# Step 1: Mapping Genomic Coordinates to Genes using biomaRt
# Connect to the Ensembl database for mouse genome annotation
ensembl <- useMart("ensembl", dataset = "mmusculus_gene_ensembl", host = "https://asia.ensembl.org")
```

```{r}
#Taking a sample set of the cpgs for debugging / running time purposes
# Step 2: Take a subset of each for testing
set.seed(123)  # For reproducibility
hyper_cpgs_subset <- hyper_cpgs %>% sample_n(1000)
hypo_cpgs_subset <- hypo_cpgs %>% sample_n(1000)

hyper_cpgs_subset <- hyper_cpgs_subset %>%
  mutate(chr = as.numeric(chr)) %>%  # Converts chromosome values to numeric, leaves NA for non-numeric
  arrange(chr, start)  

# Step 3: Check the subset data
head(hyper_cpgs_subset)
head(hypo_cpgs_subset)
dim(hyper_cpgs_subset)
dim(hypo_cpgs_subset)
```
```{r}
# Load required libraries
library(GenomicRanges)
library(GenomicFeatures)
library(AnnotationDbi)
```

```{r}
# Remove columns we don't need
hyper_cpgs_subset <- hyper_cpgs_subset[, c("chr", "start", "end", "pvalue")]
hyper_cpgs_subset <- hyper_cpgs_subset %>%
  mutate(cpg_id = paste0(chr, "_", start, "_", end))


# Display the result
print(hyper_cpgs_subset)
```

```{r}

# Construct chromosomal_region in the query dataset
hyper_cpgs_subset <- hyper_cpgs_subset %>%
  mutate(query_id = paste0(chr, "_", start, "_", end),
         chromosomal_region = paste0(chr, ":", start, "-", end))

# Retrieve gene annotations for hypermethylated CpGs
hyper_annotations <- getBM(
  attributes = c("chromosome_name", "start_position", "end_position", "ensembl_gene_id"),
  filters = "chromosomal_region",
  values = hyper_cpgs_subset$chromosomal_region,
  mart = ensembl
)
# Add chromosomal_region column to the result
hyper_annotations <- hyper_annotations %>%
  mutate(chromosomal_region = paste0(chromosome_name, "_", start_position, "_", end_position))

# Display the first few rows
head(hyper_annotations)
```
```{r}
library(dplyr)
# Assume hyper_cpgs_subset has a 'cpg_id' column with the format "chr_start_end"

hyper_cpgs_subset <- as.data.frame(hyper_cpgs_subset)
# Extract chr, start, and end from cpg_id
hyper_cpgs_subset <- hyper_cpgs_subset %>%
  mutate(
    chr = sub("^(.*)_.*_.*$", "\\1", cpg_id),
    start = as.numeric(sub("^.*_(.*)_.*$", "\\1", cpg_id)),
    end = as.numeric(sub("^.*_.*_(.*)$", "\\1", cpg_id))
  )

# Parse 'chromosomal_region' in hyper_annotations to chr, start, and end
hyper_annotations <- hyper_annotations %>%
  mutate(
    chr = sub("^(.*)_.*_.*$", "\\1", chromosomal_region),
    start = as.numeric(sub("^.*_(.*)_.*$", "\\1", chromosomal_region)),
    end = as.numeric(sub("^.*_.*_(.*)$", "\\1", chromosomal_region))
  )

# Convert CpG data to GRanges object
cpg_gr <- GRanges(
  seqnames = hyper_cpgs_subset$chr,
  ranges = IRanges(start = hyper_cpgs_subset$start, end = hyper_cpgs_subset$end),
  cpg_id = hyper_cpgs_subset$cpg_id
)

# Convert gene annotation data to GRanges object
gene_gr <- GRanges(
  seqnames = hyper_annotations$chr,
  ranges = IRanges(start = hyper_annotations$start, end = hyper_annotations$end),
  ensembl_gene_id = hyper_annotations$ensembl_gene_id
)

# Find overlaps between CpG ranges and gene ranges
overlaps <- findOverlaps(cpg_gr, gene_gr)

# Map each CpG to all overlapping genes
mapped_genes <- data.frame(
  cpg_id = mcols(cpg_gr)$cpg_id[queryHits(overlaps)],
  ensembl_gene_id = mcols(gene_gr)$ensembl_gene_id[subjectHits(overlaps)]
)

hyper_cpgs_subset <- as_tibble(hyper_cpgs_subset)

# Now, retry the join operation with dplyr::select
mapped_genes <- mapped_genes %>%
  left_join(hyper_cpgs_subset %>% dplyr::select(cpg_id, pvalue), by = "cpg_id")

# Check the result
print(head(mapped_genes))
```

```{r}
# Save the hyper_genes and hypo_genes objects as .rds files
saveRDS(hyper_genes, file = "hyper_annotations.rds")
saveRDS(hypo_genes, file = "hypo_annotations.rds")
```

```{r}
# Load the hyper_genes and hypo_genes objects from the .rds files
hyper_genes <- readRDS("rds/hyper_genes.rds")
hypo_genes <- readRDS("rds/hypo_genes.rds")
hyper_cpgs <- readRDS("rds/hyper_cpgs.rds")
hypo_cpgs <- readRDS("rds/hyper_cpgs.rds")
```

```{r}
library(methylGSA)
```

```{r}
cpg_pval <- setNames(mapped_genes$pvalue, mapped_genes$cpg_id)
head(cpg_pval)
```



```{r}
# Check the column names in mapped_genes
colnames(mapped_genes)
# Ensure that `mapped_genes` has only the CpG and Gene columns
mapped_genes_prepared <- mapped_genes[, c("cpg_id", "ensembl_gene_id")]

# Rename columns to match the expected format for `prepareAnnot`
colnames(mapped_genes_prepared) <- c("CpG", "Gene")

# Remove duplicate CpG-Gene pairs to ensure unique CpG identifiers
mapped_genes_prepared <- mapped_genes_prepared[!duplicated(mapped_genes_prepared$CpG), ]

# Verify that there are no duplicates
any(duplicated(mapped_genes_prepared$CpG))  # Should return FALSE

# Retrieve gene symbols for each Ensembl gene ID
gene_symbols <- getBM(
    attributes = c("ensembl_gene_id", "mgi_symbol"),  # Using "mgi_symbol" for mouse gene symbols
    filters = "ensembl_gene_id",
    values = mapped_genes_prepared$Gene,
    mart = ensembl
)

# Merge gene symbols back with the mapped CpG data
mapped_genes_prepared <- merge(
    mapped_genes_prepared,
    gene_symbols,
    by.x = "Gene",
    by.y = "ensembl_gene_id",
    all.x = TRUE
)

# Replace Ensembl IDs with gene symbols in FullAnnot
FullAnnot <- mapped_genes_prepared[, c("CpG", "mgi_symbol")]
colnames(FullAnnot) <- c("cpg", "gene")  # Rename to expected format
head(FullAnnot)
```
```{r}
# Install the required packages if not already installed
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install("AnnotationHub")
BiocManager::install("TxDb.Mmusculus.UCSC.mm10.knownGene")
```

```{r}
library(AnnotationHub)
library(GenomicRanges)
library(TxDb.Mmusculus.UCSC.mm10.knownGene)

ah <- AnnotationHub()
txdb <- TxDb.Mmusculus.UCSC.mm10.knownGene

# Retrieve gene coordinates
genes_mm10_gr<- genes(txdb)
head(genes_mm10_gr)
```

```{r}

cpg_mapped_genes <- mapped_genes %>%
  mutate(
    chromosome = sub("^(.*)_.*_.*$", "\\1", cpg_id),
    start = as.numeric(sub("^.*_(.*)_.*$", "\\1", cpg_id)),
    end = as.numeric(sub("^.*_.*_(.*)$", "\\1", cpg_id))
  )

# Assuming `mapped_genes` is your data frame with CpG site information
# Convert mapped CpG sites to GRanges
cpg_gr <- GRanges(
    seqnames = Rle(cpg_mapped_genes$chromosome),
    ranges = IRanges(start = cpg_mapped_genes$start, end = cpg_mapped_genes$end),
    cpg_id = cpg_mapped_genes$cpg_id
)

head(cpg_gr)
# Find overlaps with gene annotations
overlaps <- findOverlaps(cpg_gr, genes_mm10_gr)
mapped_genes <- data.frame(
    CpG = mapped_genes$cpg_id[queryHits(overlaps)],
    Gene = genes_mm10_gr$gene_id[subjectHits(overlaps)]
)
```

```{r}
# Load necessary libraries
library(BSgenome.Mmusculus.UCSC.mm10)
library(GenomicRanges)
library(AnnotationHub)
library(biomaRt)
library(dplyr)

# Step 1: Get CpG sites in mm10
genome <- BSgenome.Mmusculus.UCSC.mm10
cpg_sites <- GRanges(seqnames = seqnames(genome),
                     ranges = IRanges(start = start(genome), width = 1))

# Filter only CpG dinucleotides
cpg_gr <- cpg_sites[which(genome[cpg_sites] == "CG")]

# Assign unique IDs to each CpG site in mm10, similar to 'cg####'
cpg_df <- as.data.frame(cpg_gr)
cpg_df <- cpg_df %>%
  mutate(cg_id = paste0("cg", sprintf('%08d', 1:n())))

# Step 2: Map CpG sites to Genes using biomaRt
# Connect to Ensembl for mm10 gene annotations
mart <- useMart("ensembl", dataset = "mmusculus_gene_ensembl")

# Get gene information (adjust fields as needed)
genes <- getBM(attributes = c("ensembl_gene_id", "chromosome_name", "start_position", "end_position", "strand"),
               mart = mart)

# Convert gene information to GenomicRanges
gene_gr <- GRanges(seqnames = genes$chromosome_name,
                   ranges = IRanges(start = genes$start_position, end = genes$end_position),
                   strand = genes$strand,
                   gene_id = genes$ensembl_gene_id)

# Find overlaps between CpG sites and genes
overlaps <- findOverlaps(cpg_gr, gene_gr)

# Create a mapping data frame
cpg_to_gene <- data.frame(
  cg_id = cpg_df$cg_id[queryHits(overlaps)],
  ensembl_gene_id = genes$ensembl_gene_id[subjectHits(overlaps)]
)

# Now you have a custom CpG to gene mapping for mm10
# Save this mapping to a file for use with methylGSA
write.csv(cpg_to_gene, "cpg_to_gene_mapping_mm10.csv", row.names = FALSE)
```

```{r}
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("msigdb")
```

```{r}
library(msigdb)
library(ExperimentHub)
library(GSEABase)
```
```{r}
remove.packages("AnnotationHub")
install.packages("BiocManager")
BiocManager::install("AnnotationHub")
```

```{r}
#retrieve hallmark mouse 
msigdb.mm = getMsigdb(org = 'mm', id = 'SYM', version = '7.4')
hallmarks = subsetCollection(msigdb.mm, 'h')
print(hallmarks)
```

```{r}
# Run the methylglm function
methylglm_results_pos <- methylglm(
    cpg.pval = cpg_pval,
    array.type = "custom",
    FullAnnot = FullAnnot,   # Ensure this is a properly formatted annotation data frame for CpGs
    GS.type = "hallmarks",            # Choose appropriate gene set type, e.g., "GO" for Gene Ontology
    minsize = 200,
    maxsize = 500
)

head(methylglm_results_pos)
```

```{r}
# methylglm call for hypomethylated cpgs 
methylglm_results_neg <- methylglm(
    cpg.pval = setNames(hypo_cpgs$pvalue, hypo_cpgs$cpg_id),
    array.type = "custom",
    FullAnnot = hypo_genes,
    GS.type = "GO",
    minsize = 200,
    maxsize = 500
)
```


